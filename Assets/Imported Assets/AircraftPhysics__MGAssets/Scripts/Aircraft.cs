using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

namespace MGAssets
{
    namespace AircraftPhysics
    {

        public class Aircraft : FlightScript
        {
            [Header("another references")]
            public WarningController WarningController;

            [Header("player combat info")]
            public int playerHP = 0;

            [Header("Info Reference")]
            [SerializeField]TextMeshProUGUI aircraftDamageText;

            #region Aircraft Movements

            [Header("Status")]
            [Space]
            public Rigidbody rigidBody;
            public bool isGrounded = true;
            public bool isDamaged = false;
            public bool isBingoFuel = false;
            public bool isEngineOn = true;
            public bool isStall = false;
            public bool isBraking = false;
            public bool isGearDown = true;


            [Space]
            [Header("General Flight Settings")]
            //public ControlType mode = ControlType.Manual;
            ////public enum ControlType { Manual = 0, FlyByWire = 1, FlyByWireNavigation = 2, FlyByWireTargeting = 3 };
            //public bool allowManual = true, allowFlyByWire = true, allowNavigation = true, allowTargeting = true;

            [Space]
            [Tooltip("Intensity of the Controlling Surfaces Forces applied to Rotate / Maneuver the Aircraft. (Elevators, Ailerons, and Rudder)")]
            public float pitchFactor = 1f;
            [Tooltip("Intensity of the Controlling Surfaces Forces applied to Rotate / Maneuver the Aircraft. (Elevators, Ailerons, and Rudder)")]
            public float rollFactor = 1f, yawFactor = 1f;

            [Space]
            [Tooltip("Thrust to Weight Ratio: ~0.5 (Propelled), ~1.0 (Fighter Jets), >1.0 (Modern and Futuristic Fighters)")]
            public float thrustFactor = 1f;
            [Tooltip("0.1 ~ 1 = Instant Thrust (Propelled), < 0.1 = Slow Thrust (Jet Engines)")]
            public float throttleResponseFactor = 0.1f;

            [Space]
            [Tooltip("Amount of Lift generated by the Wing. It's Proportional to Wing Area. Higher values give more agility, sharper turns, and smaller takeoff speeds.")]
            public float wingLiftFactor = 0.5f;
            [Tooltip("Clamp Values for minimum and maximum possible G Forces generated by the Wings during maneuvers.")]
            public float maxG = 4f, minG = -2f;

            [Space]
            [Tooltip("Max theoretical Speed. Practical Max Speed will be lower, depending also on Altitude, AOA and total Drag factors.")]
            public float maxSpeed = 50f;
            [Tooltip("Minimum Speed for effectively Maneuvering. TakeOff speed usually will be slightly above the Stall Speed, depending also on WingLiftFactor and WingAlpha values.")]
            public float stallSpeed = 10f;
            [Tooltip("Altitude in which the Aircraft is not maneuverable anymore. Max Effective Altitude will be always lower than this, and it will depend on the resulting interaction of other factors like WingLift, Drag, and AOA.")]
            public float maxAltitude = 2000f;
            [Tooltip("Y in world coordinate for Zero Altitude reference (Sea Level).")]
            public float zeroAltitude = 0;

            [Space]
            [Tooltip("Height to be considered Grounded. Adjust this when you change to a different Aircraft Model.")]
            public float groundHeight = 0.3f; //0.26f;

            [Space]
            [Header("Advanced Settings")]
            [Space]
            [Tooltip("Angle of Attack increases WingLift and Drag until it reaches the MaxAOA value. If disabled, a simplified modeling will be used, in which there will be no increase in Drag and no decrease in WingLift.")]
            public bool useAOA = true;
            [Tooltip("The AOA in which the WingLift force will be at maximum. This should be equal or slightly smaller than maxAoaStall angle for a Realistic behavior.")]
            public float maxAOA = 15f;
            [Tooltip("The Torsion Angle of the Aircraft's Wing when leveled on the ground. Small angles can assist during the TakeOff procedure, but higher values will make it Stall frequently.")]
            public float wingAlpha = 5f;
            [Tooltip("The tendency for nose dropping/raising with speed.")]
            public float pitchAOAFactor = 0.025f;

            [Space]
            [Tooltip("Stall forces push back the aircraft into reducing the AOA. Without stall, aircraft may fly backward and be unstable, giving it acrobatics abilities and/or not realistic results.")]
            public bool useStall = true;
            [Tooltip("Angle of Attack in which the wing will stall.")]
            public float maxAOAStall = 15f;
            [Tooltip("Intensity of Stall Forces.")]
            public float stallFactor = 0.01f;
            [Tooltip("Percentage of the WingLift force still being applied during a Stall. 0 will make the aircraft sink faster.")]
            public float stallLiftFactor = 0.5f;
            [Tooltip("Dampening applied to Stall forces to avoid excessive oscillations.")]
            public float stallDamp = 0.01f;
            [Tooltip("Stall Alert will be triggered when the AOA is this close to the Stall Angle.")]
            public float stallAlert = 5f;

            float stallLastTime;


            [Space]
            [Tooltip("How intense are the fixed rudder forces in stabilizing the Aircraft's direction of flight. Speeds lower than the FinMinVel will not generate any force.")]
            public bool useFin = true;
            public float finFactor = 0.1f;
            public float finDamp = 0.1f;
            public float finMinVel = 1f;

            [Space]
            [Tooltip("How much the Drag is increased with the Angle of Attack. (Delta wings tend to have a higher factor)")]
            public float dragFactorAOA = 0.1f;
            //[Tooltip("How much the Drag is increased with the Speed until it reaches a max value at max speed.")]
            float maxSpeedDragFactor = 1f;
            [Tooltip("How much the Drag is decreased with higher Altitudes. Set to 0 for no Altitude influence.")]
            public float altitudeDragFactor = 0.25f;
            [Tooltip("How much the Drag is increased if the Aircraft is Damaged.")]
            public float damageDrag = 0.25f;
            [Tooltip("Clamp Values for minimum and maximum possible Drag values.")]
            public float minDrag = 0.05f, maxDrag = 1f;


            [Space]
            [Header("Center of Gravity")]
            [Space]
            [Tooltip("Gizmo is shown on Scene Window. (This is not automatically updated during runtime!)")]
            public Vector3 CG = Vector3.zero;
            [HideInInspector] public Vector3 inertiaTensor = Vector3.one;


            [Space]
            [Header("Gear, Brake & Flaps")]
            [Space]
            [Tooltip("Increase of Aerodynamic Drag when Landing Gear is down.")]
            public float gearDrag = 0f;
            [Tooltip("Increase of Aerodynamic Drag when Brake is deployed.")]
            public float brakeDrag = 1f;


            [Space]
            [Tooltip("Force Intensity applied to make turns when the Aircraft is grounded.")]
            public float gearTorque = 1f;
            [Tooltip("Friction forces between the tires and the ground when they are in contact.")]
            public float gearFriction = 0.05f;
            [Tooltip("Friction forces between the tires and the ground when Braking.")]
            public float gearBrakeFriction = 0.25f;
            [Tooltip("Friction forces between the tires and the ground when Aircraft is grounded and moving Sideways (drifting).")]
            public float gearSideFriction = 2f;
            [Tooltip("Banking forces applied to the Aircraft when it's grounded and turning relatively fast.")]
            public float gearSideBankFactor = 0.5f;


            [Space]
            public bool useLandingGear = true;
            public bool useAnimationGear = false;
            public Animator gearAnimator;
            [Tooltip("Reference to all Gear's Rigidbodies.")]
            public Rigidbody[] gearsRB;

            [Tooltip("Flaps Configuration: x = Raise in Lift, y = Raise in Drag, z = Maximum Speed allowed to deploy, w = Flap Angle (For showing on GUI only) ")]
            public Vector4[] flaps;


            [Space]
            [Header("Fuel")]
            [Space]
            public bool useFuel = true;
            public float fuel = 1f;
            [Tooltip("The Time (in Minutes) to consume 100% Fuel when Engine running at Iddle RPM - Set to 0 for no Iddle fuel consumption")]
            public float fuelIddleTime = 1f;//8f;
            [Tooltip("The Time (in Minutes) taken to consume 100% Fuel with Engine running at max RPM - Set to 0 for no fuel consumption - (Should be lower than Iddle Time)")]
            public float fuelMaxPowerTime = 0.125f; //1.6666666f;
            [Tooltip("The max allowed Fuel (1 = 100%)")]
            public float maxFuel = 1f;




            [Space]
            [Header("Damage")]
            [Space]
            public bool allowDamage = true;
            [Tooltip("Impact Velocity to cause Damage or to be considered a Touch. In-between values are considered a Hit.")]
            public float touchVel = 2f, damageVel = 20f;
            [Tooltip("Impact Velocity to cause an Explosion (Should be higher or equal than damageVel).")]
            public float explodeVel = 30f;
            [Tooltip("Prefab for the Explosion Effect.")]
            public GameObject explosionPreFab;



            [Space]
            [Header("Reset Status")]
            [Space]
            [Tooltip("Automatically Reset Aircraft state every time it's enabled.")]
            public bool resetOnEnable = false;
            [Tooltip("Instead of Recovering the Aircraft at its location, it will be sent to the Reset State.")]
            public bool resetOnRecover = true;
            [Tooltip("Reset the Aircraft to current position at the resetAltitude (and other reset states) instead of teleporting it to the initial position.")]
            public bool resetToCurrentPosition = false;
            [Tooltip("Allows the player to Reset Aircraft state at any time, otherwise, Reset will only work if the Aircraft is Damaged or Exploded.")]
            public bool alwaysAllowReset = true;

            [Space]
            public float resetHeading = 0;
            public float resetSpeed = 0;
            public float resetAltitude = 0;
            [Tooltip("Reset the Aircraft Fuel to this value. Set it to -1 if you wish to ignore and never reset the fuel value.")]
            public float resetFuel = 1f;
            public bool resetIsBraking = false;
            public bool resetIsGearDown = true;
            public int resetFlapIndex = 0;
            public float resetThrottle = 0f;
            Vector3 startPos;
            bool skipReset = false;







            [Space]
            [Header("Turbulence and Wind")]
            [Space]
            public bool useTurbulence = true;
            [Tooltip("Intensity of Turbulence forces.")]
            public float turbIntensity = 5f;
            [Tooltip("How much the Intensity of Turbulence forces is increased with the Aircraft's Speed.")]
            public float turbVelFactor = 0.1f;

            [Space]
            public bool useWind = false;
            public float windVel = 0.125f;
            public Vector3 windDir = new Vector3(1f, 0f, 0f);



            [Space]
            [Header("Sounds & Messages")]
            [Space]
            public AudioClip touchSND;
            public AudioClip hitSND, damageSND;
            public AudioClip gearSND, flapsSND, brakeSND;
            public AudioClip stallSND;
            public AudioClip bingoFuelSND;

            [Space]
            public AudioSource EngineAS;
            [Tooltip("Pitch Sound when the engine is Idle and at Full Throttle.")]
            public float minPitch = 0.25f, maxPitch = 2.0f;

            [Space]
            public string touchMSG = "Touch";
            public string hitMSG = "Hit!", damageMSG = "Propeller Damage!";
            public string bingoFuelMSG = "Out of Fuel!";
            public string flapMSG = "Flap Speed Exceeded!";
            public string recoverMSG = "Aircraft Recovered";
            public string activeMSG = "Aircraft Ready";


            [Space]
            [Header("Cameras")]
            [Space]
            public int cameraIndex = 0;
            public GameObject[] cameras;
            int camNull = 0;



            [Space(15)]
            [Header("Current Input - Read Only!")]
            [Space]
            [SerializeField] Vector3 inputForce;
            [SerializeField] Vector3 inputTorque;
            [SerializeField] float throttle;

            bool clampInput = true;

            [Space]
            [Header("Factors & Data - Read Only!")]
            [Space]
            [SerializeField] float _AoaDragFactor;
            [SerializeField] float _speedDragFactor;
            [SerializeField] float _altitudeFactor;
            [SerializeField] float _stallLiftFactor;
            [SerializeField] float _AoaLiftFactor;

            [Space]
            [SerializeField] float drag = 0.25f;
            [SerializeField] float angularDrag = 1f;
            [SerializeField] float dragTemp;
            [SerializeField] float dragFactors;
            [SerializeField] float liftTemp;
            [SerializeField] float finTemp;

            [Space]
            [SerializeField] public Vector3 relativeAngularSpeed;
            [SerializeField] public Vector3 relativeSpeed;

            [Space]
            [SerializeField] float alpha;
            [SerializeField] float beta;
            [SerializeField] float vel2;
            [SerializeField] float vel2stall;
            [SerializeField] float mg;


            [Space]
            [SerializeField] float fuelFlow;
            [SerializeField] int indexFlap = 0;
            [SerializeField] Vector4 currentFlap = new Vector4(0f, 0f, 999f, 0f);

            [Space]
            [Header("Gizmos - Editor Only")]
            [Space]
            public bool showGizmo = true;
            public float trailDuration = 25f;

            [Space]
            [SerializeField] GameObject firstPersonHUDObj;

            bool firstTime = true;

            #endregion

            ////////////////// Inicialization
            void Awake()
            {
                if (rigidBody == null) rigidBody = GetComponent<Rigidbody>();
                if (rigidBody != null) rigidBody.maxAngularVelocity = 10f; //raise default value here if necessary
                for (int i = 0; i < gearsRB.Length; i++) if (gearsRB[i] != null) gearsRB[i].maxAngularVelocity = 10f;

                rigidBody.angularDrag = angularDrag;

                setStartState();
            }
            //
            void OnEnable()
            {
                // First Initialization with Reset Enabled
                if (firstTime && resetOnEnable)
                {
                    firstTime = false;
                    rigidBody.gameObject.SetActive(false);
                    Invoke("resetToStartState", 0.5f);
                    return;
                }
                firstTime = false;
                //


                //if (current && current != this) current.transform.parent.gameObject.SetActive(false); // Auto Disable other Aircrafts
                current = this;

                updateCG();

                if (resetOnEnable) resetToStartState();
                skipReset = false;

                if (useAnimationGear && gearAnimator)
                {
                    gearAnimator.SetBool("isGearDown", isGearDown);
                }


                setCamera(cameraIndex);
                //if (!isDamaged) HudMsg.ShowQuick(activeMSG); else HudMsg.ShowQuick(damageMSG);
            }
            //
            void OnDisable()
            {
                if (current == this) current = null;
            }
            ////////////////// Inicialization




            ////////////////////////////////////// Aircraft Physics
            void FixedUpdate()
            {
                // Pr?Data Calculations
                calculateData();
                checkIsGrounded();
                checkStall();


                // Set current Throttle value and Engine Sound Pitch
                setThrottle();
                setEngineSound();


                // Physics Calculations
                calculateFactors();
                updateDrag();
                applyTorque();
                applyWingLift();
                applyRudderTorque();
                applyThrustForce();
                applyGearForce();
                applyTurbulence();
                updateFuel();
            }
            //
            //
            void calculateData()
            {
                relativeAngularSpeed = rigidBody.transform.InverseTransformDirection(rigidBody.angularVelocity);
                relativeSpeed = rigidBody.transform.InverseTransformDirection(rigidBody.velocity);
                //float velAbs = relativeSpeed.magnitude;

                alpha = Vector2.SignedAngle(new Vector2(relativeSpeed.z, relativeSpeed.y), Vector2.right);
                beta = Vector2.SignedAngle(new Vector2(relativeSpeed.x, relativeSpeed.z), Vector2.up);

                vel2 = (relativeSpeed.z * relativeSpeed.z);

                vel2stall = stallSpeed * stallSpeed;
                mg = rigidBody.mass * Physics.gravity.magnitude;

                isEngineOn = (!isDamaged && !isBingoFuel);

                //Max speed Ref
                ////float velMax2 = (thrustFactor * Physics.gravity.magnitude) / (drag + 0.00001f);
            }
            //
            void checkIsGrounded()
            {
                // Verify if is Grounded using a RayCast below
                RaycastHit hit;
                Physics.Raycast(transform.position, -transform.up, out hit, groundHeight);
                if (hit.collider != null && hit.collider.gameObject != this.gameObject && hit.collider.transform.parent != this.transform) isGrounded = true; else isGrounded = false;

                if (showGizmo)
                {
                    if (hit.collider != null) Debug.DrawLine(transform.position, hit.point, Color.yellow, trailDuration /*2.5f*/);
                    else Debug.DrawLine(transform.position, transform.position + (groundHeight /*0.26f*/) * -transform.up, Color.yellow, 2.5f);
                }
            }
            //
            void checkStall()
            {
                // Stall Warning
                if (useStall && !isDamaged && !isGrounded && Mathf.Abs(alpha) >= maxAOAStall - stallAlert)
                {
                    isStall = true;
                    if (stallSND && (Time.time - stallLastTime) > stallSND.length) { stallLastTime = Time.time; AircraftSnd.Play(stallSND); }
                }
                else isStall = false;
            }
            //
            void setThrottle()
            {
                if (isEngineOn) throttle = Mathf.Lerp(throttle, inputForce.z, throttleResponseFactor);
                else
                {
                    throttle = Mathf.Lerp(throttle, 0, throttleResponseFactor);
                    if (Mathf.Abs(throttle) < 0.05f) throttle = 0;
                }
            }
            //
            void setEngineSound()
            {
                if (EngineAS != null && EngineAS.isActiveAndEnabled)
                {
                    if (!EngineAS.isPlaying && isEngineOn) EngineAS.Play();
                    if (isEngineOn) EngineAS.pitch = Mathf.Lerp(minPitch, maxPitch, Mathf.Abs(throttle));
                    else
                    {
                        if (throttle != 0) EngineAS.pitch = Mathf.Lerp(minPitch, maxPitch, Mathf.Abs(throttle));
                        else
                        {
                            EngineAS.Stop();
                            EngineAS.pitch = 1;
                        }
                    }
                }
            }
            //
            void calculateFactors()
            {
                _speedDragFactor = maxSpeedDragFactor * Mathf.Abs(vel2 / (maxSpeed * maxSpeed));
                _AoaDragFactor = dragFactorAOA * (useAOA ? Mathf.Abs(Mathf.Sin((alpha + wingAlpha) * Mathf.Deg2Rad)) + 0.25f * Mathf.Abs(Mathf.Sin((beta) * Mathf.Deg2Rad)) : 0f);
                _altitudeFactor = Mathf.Clamp01(1f - (rigidBody.transform.position.y - zeroAltitude) / maxAltitude);
                _stallLiftFactor = (useStall ? (Mathf.Abs(alpha) <= maxAOAStall ? 1f : stallLiftFactor) : 1f);
                _AoaLiftFactor =
                    (useAOA ?
                    Mathf.Sin(Mathf.Clamp(90f * (alpha + wingAlpha) / maxAOA, -180, +180) * Mathf.Deg2Rad)
                    : (Mathf.Abs(alpha) <= maxAOA ? Mathf.Sin((alpha + wingAlpha) * Mathf.Deg2Rad) : 1f)
                    );
            }
            //
            void updateDrag()
            {
                dragTemp = (thrustFactor * Physics.gravity.magnitude) / maxSpeed;
                dragFactors = 1 + _AoaDragFactor + altitudeDragFactor * _altitudeFactor + currentFlap.y + (isGearDown ? gearDrag : 0) + (isBraking ? brakeDrag : 0);
                drag = Mathf.Clamp(dragTemp * _speedDragFactor * dragFactors + (isDamaged ? damageDrag : 0), minDrag, maxDrag);

                rigidBody.drag = drag;

                //print("dragTemp = " + dragTemp + " // Factor = " + ((1 + _AoaDragFactor + altitudeDragFactor * _altitudeFactor + currentFlap.y + (isGearDown ? gearDrag : 0) + (isBraking ? brakeDrag : 0))));
            }
            //
            void applyTorque()
            {
                //// Input Torque Force - Pitch, Roll, Yaw
                //rigidBody.AddRelativeTorque(inputTorque.x * pitchFactor, inputTorque.y * yawFactor, inputTorque.z * rollFactor, ForceMode.Force);
                rigidBody.AddRelativeTorque(
                    inputTorque.x * pitchFactor * Mathf.Clamp01(vel2 / vel2stall) * _altitudeFactor * (((useStall && Mathf.Abs(alpha) > maxAOAStall && Mathf.Sign(inputTorque.x) != Mathf.Sign(alpha)) ? 0 : 0.5f))
                    + ((useAOA) ? pitchAOAFactor * (Mathf.Sin(alpha * Mathf.Deg2Rad) * Mathf.Abs(Mathf.Sin(alpha * Mathf.Deg2Rad)) * vel2) : 0)
                    ,
                    inputTorque.y * yawFactor * Mathf.Clamp01(vel2 / vel2stall) * _altitudeFactor +
                    (isGrounded && vel2 > 0.25f ? inputTorque.y * gearTorque * Mathf.Sign(relativeSpeed.z) * Mathf.Clamp01(1 - vel2 / vel2stall) : 0)
                    ,
                    inputTorque.z * rollFactor * Mathf.Clamp01(vel2 / vel2stall) * _altitudeFactor,
                    ForceMode.Force);


                //// Stall Torque Force
                if (useStall && Mathf.Abs(alpha) > maxAOAStall) rigidBody.AddRelativeTorque(stallFactor * (Mathf.Sin(alpha * Mathf.Deg2Rad) * Mathf.Abs(Mathf.Sin(alpha * Mathf.Deg2Rad)) * vel2 - stallDamp * relativeAngularSpeed.x) * Vector3.right, ForceMode.Force);
            }
            //
            void applyWingLift()
            {
                liftTemp = 0.01f * (wingLiftFactor + currentFlap.x) * _AoaLiftFactor * _stallLiftFactor * _altitudeFactor * vel2 * mg;
                liftTemp = Mathf.Clamp(liftTemp, minG * Physics.gravity.magnitude, maxG * Physics.gravity.magnitude);
                rigidBody.AddRelativeForce(0, liftTemp, 0, ForceMode.Force);

                //print("Lift Wing g = " + liftTemp / Physics.gravity.magnitude + " // FactorNoAlpha = " + (wingLiftFactor * _stallLiftFactor * _altitudeFactor) + "    // FactorsTotal =  " + (wingLiftFactor * _AoaLiftFactor * _stallLiftFactor * _altitudeFactor) );
            }
            //
            void applyRudderTorque()
            {
                // Rudder, Fin Forces
                if (useFin && finFactor != 0 && Mathf.Abs(relativeSpeed.x) >= finMinVel)
                {
                    finTemp = ((Mathf.Abs(relativeSpeed.x) >= finMinVel) ? finFactor * Mathf.Sin(beta * Mathf.Deg2Rad) * Mathf.Abs(Mathf.Sin(beta * Mathf.Deg2Rad)) * (relativeSpeed.x * relativeSpeed.x - finMinVel * finMinVel) : 0) - (finDamp * relativeAngularSpeed.y);
                    finTemp = Mathf.Clamp(finTemp, -yawFactor, yawFactor);

                    rigidBody.AddRelativeTorque(finTemp * Vector3.up, ForceMode.Force);

                    //print("finTemp = " + finTemp + " // relativeSpeed.x = " + relativeSpeed.x);
                }
            }
            //
            void applyThrustForce()
            {
                if (isEngineOn && !isDamaged)
                {
                    rigidBody.AddRelativeForce(0, 0, throttle * thrustFactor * mg, ForceMode.Force);
                }
            }
            //
            void applyGearForce()
            {
                // Gear Friction, Brake and Centrifugal-Bank forces
                if (isGrounded)
                {
                    rigidBody.AddRelativeForce(gearSideFriction * -relativeSpeed.x * Vector3.right - gearFriction * relativeSpeed.z * Vector3.forward + (isBraking ? -Mathf.Sign(relativeSpeed.z) * gearBrakeFriction * mg : 0) * Vector3.forward, ForceMode.Force);
                    rigidBody.AddRelativeTorque(Vector3.forward * gearSideBankFactor * (relativeAngularSpeed.y * relativeSpeed.z), ForceMode.Force);
                }
            }
            //
            void applyTurbulence()
            {
                // Turbulence
                if (useTurbulence && !isGrounded && (!isDamaged || (isDamaged && rigidBody.velocity.magnitude > 0.1f)))
                {
                    rigidBody.AddRelativeTorque(
                        rigidBody.mass * (isDamaged ? 0.05f : 0.01f) *
                        new Vector3
                        (
                            Random.Range(-turbIntensity, turbIntensity) * (1 + rigidBody.velocity.magnitude * turbVelFactor)
                            ,
                            Random.Range(-turbIntensity / 2f, turbIntensity / 2f) * (1 + rigidBody.velocity.magnitude * turbVelFactor / 2f)
                            ,
                            Random.Range(-turbIntensity, turbIntensity) * (1 + rigidBody.velocity.magnitude * turbVelFactor)
                        )
                        , ForceMode.Force);
                }

                // Wind
                if (useWind && !isGrounded)
                {
                    rigidBody.AddForce(mg * windVel * windDir.normalized, ForceMode.Acceleration);
                }
            }
            //
            void updateFuel()
            {
                if (useFuel)
                {
                    fuel = Mathf.Clamp(fuel, 0, maxFuel);

                    if (!isBingoFuel && throttle != 0 && fuel > 0)
                    {
                        //Consumption in Minutes for 100% Fuel between Iddle and Full Throttle
                        fuelFlow = Time.fixedDeltaTime * Mathf.Lerp((fuelIddleTime >= 1 ? 1f / (60f * fuelIddleTime) : 0), (fuelMaxPowerTime >= 1 ? 1f / (60f * fuelMaxPowerTime) : 0), throttle * throttle);
                        fuel -= fuelFlow;
                    }
                    else fuelFlow = 0;

                    if (!isBingoFuel && fuel <= 0.005f)
                    {
                        isBingoFuel = true;
                        fuel = 0;

                        AircraftSnd.Play(bingoFuelSND);
                        HudMsg.Show(bingoFuelMSG, 2f);
                    }
                }
                else isBingoFuel = false;
            }
            //
            ////////////////////////////////////// Aircraft Physics







            //////////////////////////////////////// Collision Sounds, Msgs, Damage and Recovery-StartState
            public void damage()
            {
                isDamaged = true;
                rigidBody.AddRelativeTorque(Mathf.Sign(Random.Range(-1, 1)) * rigidBody.velocity, ForceMode.Impulse);

                AircraftSnd.Play(damageSND);
            }
            public void explode()
            {
                isDamaged = true;
                if (explosionPreFab) Instantiate(explosionPreFab, transform.position, Quaternion.identity, null);

                rigidBody.gameObject.SetActive(false);
                gameObject.SetActive(false);
            }
            //
            public override void recoverAttitude()
            {
                // Check if Recover/Reset is allowed
                if (!alwaysAllowReset && !isDamaged && !isBingoFuel) return;


                // Reset instead of Recovering
                if (resetOnRecover)
                {
                    resetToStartState();
                    return;
                }


                // Reset Rigidbodies
                rigidBody.velocity = Vector3.zero;
                rigidBody.angularVelocity = Vector3.zero;
                transform.localEulerAngles = new Vector3(0, transform.localEulerAngles.y, 0);


                // Landing Gears
                for (int i = 0; i < gearsRB.Length; i++)
                {
                    gearsRB[i].velocity = Vector3.zero;
                    gearsRB[i].angularVelocity = Vector3.zero;
                }

                // Fuel
                if (useFuel && isBingoFuel && resetFuel > 0)
                {
                    fuel = resetFuel;
                    isBingoFuel = false;
                }

                throttle = 0;
                isDamaged = false;

                rigidBody.transform.position += Vector3.up * (isGrounded ? 1.5f * groundHeight : 0);
                if (useLandingGear && useAnimationGear && gearAnimator) gearAnimator.Rebind();
                if (useLandingGear) setGear(true);

                setFlaps(0);
                setBrake(false);

                if (recoverDelegate != null) recoverDelegate();


                if (!rigidBody.gameObject.activeInHierarchy && resetOnEnable && !resetOnRecover) skipReset = true;
                rigidBody.gameObject.SetActive(true);
                HudMsg.Show(recoverMSG, 3f);
            }
            //
            [ContextMenu("ResetToStartState")] void resetToStartStateContext() { resetToStartState(); }
            public void resetToStartState()
            {
                // Skip Reset Cases
                if (skipReset)
                {
                    skipReset = false;
                    return;
                }

                if (!rigidBody.gameObject.activeInHierarchy && resetOnEnable)
                {
                    rigidBody.gameObject.SetActive(true);
                    return;
                }
                //

                // Set Rigidbodies Position and Velocity
                if (resetToCurrentPosition) rigidBody.transform.localPosition = new Vector3(rigidBody.transform.localPosition.x, resetAltitude, rigidBody.transform.localPosition.z);
                else rigidBody.transform.localPosition = new Vector3(startPos.x, resetAltitude, startPos.z);

                rigidBody.transform.localRotation = Quaternion.Euler(0, resetHeading, 0);

                rigidBody.velocity = rigidBody.transform.TransformDirection(Vector3.forward) * resetSpeed;
                rigidBody.angularVelocity = Vector3.zero;


                // Landing Gears
                for (int i = 0; i < gearsRB.Length; i++)
                {
                    gearsRB[i].velocity = rigidBody.velocity;
                    gearsRB[i].angularVelocity = rigidBody.angularVelocity;
                }


                // Fuel
                if (useFuel && resetFuel > 0)
                {
                    fuel = resetFuel;
                    isBingoFuel = false;
                }

                throttle = resetThrottle;
                isDamaged = false;

                if (useLandingGear)
                {
                    if (useLandingGear && useAnimationGear && gearAnimator) gearAnimator.Rebind();
                    setGear(resetIsGearDown);
                }
                setFlaps(resetFlapIndex);
                setBrake(resetIsBraking);

                if (recoverDelegate != null) recoverDelegate();

                rigidBody.gameObject.SetActive(true);
            }

            //[ContextMenu("SetStartState")] void setStartStateContext() { setStartState(); }
            void setStartState()
            {
                startPos = rigidBody.transform.localPosition;


                ////startPos = rigidBody.transform.localPosition;
                //////startAltitude = rigidBody.transform.localPosition.y;

                ////startHeading = rigidBody.transform.localEulerAngles.y;
                //////startSpeed = relativeSpeed.z;

                ////startFuel = fuel;
                ////startBraking = isBraking;
                ////startGearDown = isGearDown;
                ////startFlapIndex = indexFlap;
            }
            //

            public TargettingSystem targettingSystem;


            // 직접수정, triggered collider == 적 감지 범위.
            void OnTriggerEnter(Collider other)
            {
                if (other.gameObject != this.gameObject && other.transform.parent != this.transform && other.gameObject.CompareTag("Enemy"))
                {
                    targettingSystem.AddTarget(other.transform);

                }
            }

            void OnTriggerExit(Collider other)
            {
                // 적 기체가 범위에서 나갈 때
                if (other.CompareTag("Enemy"))
                {
                    targettingSystem.RemoveTarget(other.transform);
                }
            }
            //

            // Collision Sounds and Msgs
            void OnCollisionEnter(Collision collision)
            {
                if (collision.gameObject.CompareTag("Ground"))
                {
                    if (collision.relativeVelocity.magnitude < 0.1f) return;
                    else if (collision.relativeVelocity.magnitude <= touchVel)
                    {
                        if (touchMSG != string.Empty && !isDamaged) HudMsg.Show(touchMSG, 0.75f);
                        if (touchSND != null) AircraftSnd.Play(touchSND);
                    }
                    else if (collision.relativeVelocity.magnitude < damageVel || (!allowDamage && collision.relativeVelocity.magnitude < explodeVel))
                    {
                        if (hitMSG != string.Empty && !isDamaged) HudMsg.Show(hitMSG, 0.75f);
                        if (hitSND != null) AircraftSnd.Play(hitSND);
                    }
                    //else if (allowDamage && !isDamaged && collision.relativeVelocity.magnitude > damageVel) damage();
                    else if (allowDamage && !isDamaged && collision.relativeVelocity.magnitude < explodeVel) damage();
                    else if (!isDamaged && collision.relativeVelocity.magnitude >= explodeVel) explode();
                }
                else
                {
                    UpdateHP();
                    WarningController.DamageUIReact();
                    if (playerHP < 0) explode();
                    return;
                }
           }

            void UpdateHP()
            {
                int shownHP = 100 - playerHP;
                aircraftDamageText.text = "<align=left>DMG<line-height=0>\n<align=right>" + shownHP.ToString() + "%<line-height=1em>";
            }
            //////////////////////////////////////// Collision Sounds, Msgs, Damage and Recovery-StartState















            //////////////////////////////////////// Cycle Cameras
            public void setCamera(int index)
            {
                if (cameras.Length == 0) return;
                for (int i = 0; i <= cameras.Length - 1; i++) if (cameras[i] != null) cameras[i].SetActive(false);

                if (index < cameras.Length) cameraIndex = index; else cameraIndex = cameras.Length - 1;
                if (cameraIndex >= 0) cameras[cameraIndex].SetActive(true);

                

            }
            public override void changeCamera()
            {
                if (cameraIndex == -1 || cameras.Length == 0) return;

                cameraIndex++;
                if (cameraIndex > cameras.Length - 1 || cameraIndex < 0) cameraIndex = 0;
                if (cameras[cameraIndex].gameObject == null)
                {
                    if (camNull >= cameras.Length) { camNull = 0; return; } else { camNull++; changeCamera(); return; }
                }

                if (cameraIndex == 0) firstPersonHUDObj.SetActive(true);
                else
                {
                    firstPersonHUDObj.SetActive(false);
                }

                for (int i = 0; i <= cameras.Length - 1; i++)
                {
                    if (cameras[i] != null)
                    {
                        if (i == cameraIndex) cameras[i].SetActive(true); else cameras[i].SetActive(false);
                    }
                }
            }
            public override int getCamIndex() { return cameraIndex; }
            //////////////////////////////////////// Cycle Cameras



            //////////////////////////////////////// Flaps + Gear + Brake + Fuel
            public override void flapsDown()
            {
                if (indexFlap + 1 >= flaps.Length) return;

                if (relativeSpeed.z > flaps[indexFlap + 1].z)
                {
                    HudMsg.Show(flapMSG, 0.75f);
                    return;
                }

                indexFlap++;
                currentFlap = flaps[indexFlap];
                AircraftSnd.Play(flapsSND);

                if (flapsDelegate != null) flapsDelegate();
                return;
            }
            public override void flapsUp()
            {
                if (indexFlap <= 0) return;

                indexFlap--;
                currentFlap = flaps[indexFlap];
                AircraftSnd.Play(flapsSND);

                if (flapsDelegate != null) flapsDelegate();
                return;
            }
            void setFlaps(int index)
            {
                if (index > flaps.Length - 1) index = flaps.Length - 1;
                if (index < 0) index = 0;

                indexFlap = index;
                currentFlap = flaps[indexFlap];
                if (flapsDelegate != null) flapsDelegate();
            }
            //
            public override void toogleBrake()
            {
                isBraking = !isBraking;
                AircraftSnd.Play(brakeSND);

                if (brakeDelegate != null) brakeDelegate();
            }
            void setBrake(bool active)
            {
                isBraking = active;
                if (brakeDelegate != null) brakeDelegate();
            }
            //
            public override void toogleGear()
            {
                if (!useLandingGear) return;
                if (isGrounded) return;
                if (useAnimationGear && gearAnimator)
                {
                    if (gearAnimator.GetCurrentAnimatorStateInfo(0).normalizedTime < 1) return;
                }

                setGear(!isGearDown);

                AircraftSnd.Play(gearSND);
            }
            void setGear(bool down)
            {
                isGearDown = down;

                bool skip = false;
                if (useAnimationGear && gearAnimator)
                {
                    gearAnimator.SetBool("isGearDown", isGearDown);
                    if (isGearDown) skip = true;
                }

                if (!skip)
                {
                    for (int i = 0; i < gearsRB.Length; i++)
                    {
                        if (gearsRB[i]) gearsRB[i].gameObject.SetActive(isGearDown);

                        gearsRB[i].velocity = rigidBody.velocity;
                        gearsRB[i].angularVelocity = rigidBody.angularVelocity;
                    }

                    updateCG();
                }

                if (gearDelegate != null) gearDelegate();
            }
            public void updateGearAnim()
            {
                if (!useAnimationGear || !gearAnimator) return;

                for (int i = 0; i < gearsRB.Length; i++)
                {
                    if (gearsRB[i]) gearsRB[i].gameObject.SetActive(isGearDown);

                    if (isGearDown)
                    {
                        gearsRB[i].velocity = rigidBody.velocity;
                        gearsRB[i].angularVelocity = rigidBody.angularVelocity;

                    }
                }

                updateCG();
            }
            //
            public override void setFuel(float value)
            {
                fuel = value;
                if (fuel > 0) isBingoFuel = false;
                return;
            }
            public override void addFuel(float value)
            {
                fuel += value;
                if (fuel > 0) isBingoFuel = false;
                return;
            }
            //////////////////////////////////////// Flaps + Gear + Brake





            //////////////////////////////////////// External Get Aircraft Values
            public override float getFlapsAngle() { return flaps[indexFlap].w; }
            public override float getFlaps()
            {
                // Normalized by index value
                return (float)(indexFlap) / (float)Mathf.Clamp((flaps.Length - 1), 1, flaps.Length);

                //return flap.w;
                //return flaps[indexFlap].w;
                //return currentFlap; 
            }

            public override bool getIsGearDown() { return isGearDown; }
            public override bool getIsBraking() { return isBraking; }

            public override bool getIsGrounded() { return isGrounded; }
            public override bool getIsDamaged() { return isDamaged; }
            public override bool getIsBingoFuel() { return isBingoFuel; }
            public override float getThrottle() { return throttle; }
            public override bool getEngineOn() { return isEngineOn; }
            public override float getForwardSpeed() { return relativeSpeed.z; }
            public override Vector3 getSpeed() { return relativeSpeed; }
            public override Vector3 getAngularSpeed() { return relativeAngularSpeed; }
            public override float getAltitude() { return (rigidBody.transform.position.y - zeroAltitude); }
            public override float getFuel() { return fuel; }
            public override float getFuelFlow() { return fuelFlow; }
            //////////////////////////////////////// External Get Aircraft Values






            ////////////////////////////////////// Input Reading
            public override void setInputForce(Vector3 inputValue)
            {
                if (!clampInput) inputForce = inputValue;
                else inputForce = new Vector3(Mathf.Clamp(inputValue.x, -1f, 1f), Mathf.Clamp(inputValue.y, -1f, 1f), Mathf.Clamp(inputValue.z, -1f, 1f));
            }
            public void setInputForceX(float input) { setInputForce(new Vector3(input, inputForce.y, inputForce.z)); }
            public void setInputForceY(float input) { setInputForce(new Vector3(inputForce.x, input, inputForce.z)); }
            public void setInputForceZ(float input) { setInputForce(new Vector3(inputForce.x, inputForce.y, input)); }
            //
            public override void setInputTorque(Vector3 inputValue)
            {
                if (!clampInput) inputTorque = inputValue;
                else inputTorque = new Vector3(Mathf.Clamp(inputValue.x, -1f, 1f), Mathf.Clamp(inputValue.y, -1f, 1f), Mathf.Clamp(inputValue.z, -1f, 1f));
            }
            public void setInputTorqueX(float input) { setInputTorque(new Vector3(input, inputTorque.y, inputTorque.z)); }
            public void setInputTorqueY(float input) { setInputTorque(new Vector3(inputTorque.x, input, inputTorque.z)); }
            public void setInputTorqueZ(float input) { setInputTorque(new Vector3(inputTorque.x, inputTorque.y, input)); }
            public override Vector3 getInputTorque() { return inputTorque; }
            public override Vector3 getInputForce() { return inputForce; }

            ////////////////////////////////////// Input Reading
















            ///////////////// Center of Gravity + Gizmos
            [ContextMenu("UpdateCG")] void UpdateCGContext() { updateCG(); }
            void updateCG()
            {
                for (int i = 0; i < gearsRB.Length; i++)
                {
                    gearsRB[i].centerOfMass = Vector3.zero;
                    gearsRB[i].inertiaTensor = new Vector3(0.001f, 0.001f, 0.001f); //Vector3.one;
                    gearsRB[i].inertiaTensorRotation = Quaternion.identity;
                }

                rigidBody.centerOfMass = CG; //Vector3.zero;
                rigidBody.inertiaTensor = inertiaTensor; //Vector3.one;
                rigidBody.inertiaTensorRotation = Quaternion.identity;


                //print("rigidBody.inertiaTensor = " + rigidBody.inertiaTensor + " / inertiaTensorRotation = " + rigidBody.inertiaTensorRotation);
            }
            void resetCG()
            {
                rigidBody.ResetCenterOfMass();
                rigidBody.ResetInertiaTensor();
            }

            void OnDrawGizmosSelected()
            {
                //Gizmos.color = Color.red;
                Gizmos.color = new Color(1, 0, 0, 0.5f);
                Gizmos.DrawSphere(transform.position + transform.TransformDirection(CG), 0.15f);
            }
            ///////////////// Center of Gravity + Gizmos

        }
    }
}